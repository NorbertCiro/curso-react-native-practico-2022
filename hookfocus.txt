Cuando usamos un useEffect buscamos que una acci√≥n se ejecute al renderizar nuestro c√≥digo
una o multiples veces seg√∫n las dependencias que este hook est√° observando. 
El problema por el que no aparecen nuestros favoritos actualizados es que la Screen solo se 
renderiza una vez, luego cuando cambiamos de screen y volvemos a ella cambia es el ‚Äúfoco‚Äù, 
es decir, dejamos de enfocar esa screen o la volvemos a enfocar, pero el renderizado ya ocurri√≥. 
Esto permite mantener buen performance en la app‚Ä¶ Pero nos trae problemas como este.
.
¬øEntonces a qu√© viene el useFocusEffect?
Pues este hook de react navigation justamente nos ayuda a activar una secci√≥n de c√≥digo tal como lo 
har√≠a un useEffect durante el renderizado, pero cada vez que una pantalla sea enfocada en nuestra 
aplicaci√≥n. De este modo solventamos el problema de no tener nuestro favoritos actualizados‚Ä¶ 
Pero ahora hay otro problema.
.
useFocusEffect es un hook que recibe un callback para su ejecuci√≥n, por esta raz√≥n un useEffect 
no nos servir√≠a en este caso, ya que al tratar de asignarlo a una constante dentro del useFocusEffect 
se romper√≠a (puedes probarlo poniendo un useEffect dentro del useFocusEffect).
.
¬øPero por qu√© usar useCallback en lugar de cualquier callback creado por nosotros?
Performance y practicidad üòÉ no nos cuesta nada agregarlo, y el hook de useCallback nos permite 
decirle al c√≥digo ‚Äúhey, que te voy a usar muchas veces, entonces no me re-renderices todo si en el 
fondo la informaci√≥n no ha cambiado‚Äù. Y esto es muy √∫til en t√©rminos de performance, esto ocurre 
porque el hook de useCallback tiene un comportamiento de ‚Äúmemoizaci√≥n‚Äù.